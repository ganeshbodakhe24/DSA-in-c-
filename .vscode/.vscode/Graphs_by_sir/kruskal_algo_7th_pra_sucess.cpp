//krushkal algo
#include <iostream>
using namespace std;


int numvirtex ; // number of edges present in the
int numedges  ;

int cost = 0; // total cost of minimum spanning tree
int M[10][10];//adjecency matrix of graph
/*int M[n][n]{
    {0, 3, 0, 0, 1, 4},
    {3, 0, 2, 0, 0, 9},
    {0, 2, 0, 8, 0, 6},
    {0, 0, 8, 0, 2, 0},
    {1, 0, 0, 2, 0, 0},
    {4, 9, 6, 0, 0, 0}

};
int M[n][n]{
    {0, 1, 3, 3, 1},
    {3, 0, 4, 2, 2},
    {0, 2, 0, 0, 4},
    {0, 0, 8, 0, 3},
    {1, 0, 0, 2, 0}
   

};
int M[n][n]{
    {0, 25, 0, 0, 0, 0, 10},
    {0, 0, 15, 9, 0, 0, 0},
    {8, 20, 0, 25, 0, 0, 0},
    {0, 0, 11, 0, 7, 0, 0},
    {2, 0, 0, 12, 0, 50, 55},
    {17, 0, 0, 0, 15, 0, 30},
    {0, 6, 0, 0, 0, 18, 0}

};
int M[n][n]{
    {0, 7, 6, 1, 0, 0},
    {3, 0, 8, 0, 0, 0},
    {0, 2, 0, 5, 3, 0},
    {0, 0, 8, 0, 4, 5},
    {1, 0, 0, 2, 0, 2},
    {4, 9, 6, 0, 0, 0}

};
*/
int N[10][10]; // graph generated by kushkal algo

int visited[10]; // node is visited or not

int set[16][3]; // this is the set which is use to store the edges;
// set[a][0]=i; set[a][1]=j; set[a][2]=value of edge;

int chVirtex[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; // choice of vertex for DFS

//initiate th vertex visited all value is zero that mean no vertex is visited
void chVirtexInitiate()
{
    for (int i = 0; i < 10; i++)
    {
        chVirtex[i] = 0;
    }
}

//initiate second graph edge value set as zero
void initiate()
{
    for (int i = 0; i < 10; i++)
    {
        for (int j = 0; j < 10; j++)
        {

            N[i][j] = 0;
        }
        visited[i] = 0;
    }
}


void DFS(int i)
{
    chVirtex[i] = 1;
    for (int j = 0; j < numvirtex; j++)
    {
        if (N[i][j]!=0)
        {
            if (chVirtex[j] != 1)
            {
                DFS(j);
                chVirtex[j] = 1;
            }
        }
    }
}


void kushkalAlgoUndirected()
{   int flag=0;
    int m = 0;
    int a = 0; // this is the pointer of set array
               // storing the edges value into the array

    for (int i = 0; i < numvirtex; i++)
    {
        for (int j = i + 1; j < numvirtex; j++)
        {
            if (M[i][j] != 0)
            {   //add visited value in set array with index i and j and value
                set[a][0] = i;
                set[a][1] = j;
                set[a][2] = M[i][j];

                a++;
            }
        }
    }

    // sorting the set array;
    for (int i = 1; i <= numedges; i++)
    {
        for (int j = 0; j < numedges - i; j++)
        {
            if (set[j][2] >= set[j + 1][2])
            {
                int temp1 = set[j][0];
                int temp2 = set[j][1];
                int temp3 = set[j][2];
                set[j][0] = set[j + 1][0];
                set[j][1] = set[j + 1][1];
                set[j][2] = set[j + 1][2];
                set[j + 1][0] = temp1;
                set[j + 1][1] = temp2;
                set[j + 1][2] = temp3;
            }
        }
    }

    // making kuskals minimum spanning tree
    m = a;
    a = 0;
    
    while (a != m)
    {
        if (visited[set[a][0]] != 1 || visited[set[a][1]] != 1)
        {
            visited[set[a][0]] = 1;
            visited[set[a][1]] = 1;
            N[set[a][0]][set[a][1]] = set[a][2];
            N[set[a][1]][set[a][0]] = set[a][2];
            cost = cost + set[a][2];
            
        }

        else if(flag==0)
        {
            
            DFS(set[a][0]);
            if (chVirtex[set[a][1]] != 1)
            {
                N[set[a][0]][set[a][1]] = set[a][2];
                cout << set[a][2];
                N[set[a][1]][set[a][0]] = set[a][2];
                cost = cost + set[a][2];
                for (int i = 0; i < 10; i++)
                {
                    cout<<chVirtex[i] ;
                }cout<<endl;
              flag=1;
                chVirtexInitiate();
            }

        }
        a++;
    }
}
//make undirected graph by user
void undirectedGraph()
{
    int i, j;
    int edge;
    int m = 0;
    while (m != numedges)
    {
        cout << "\nEnter edge virtex first then second : ";
        cin >> i;
        cout << endl;
        cin >> j;
        cout << "\nEnter edge value : ";
        cin >> edge;
        M[i][j] = edge;
        M[j][i] = edge;
        m++;
    }
}
//display the first graph which make by user
void display()
{
    for (int i = 0; i < numvirtex; i++)
    {
        for (int j = 0; j < numvirtex; j++)
        {
            if (M[i][j] >= 10)
            {
                cout << "  " << M[i][j];
            }
            else
            {
                cout << "  0" << M[i][j];
            }
        }
        cout << endl;
    }
}
//display the minimum spanning tree by adjency matrix
void display_min_spanning_tree()
{
    for (int i = 0; i < numvirtex; i++)
    {
        for (int j = 0; j < numvirtex; j++)
        {
            if (N[i][j] >= 10)
            {
                cout << "  " << N[i][j];
            }
            else
            {
                cout << "  0" << N[i][j];
            }
        }
        cout << endl;
    }
}

int main()
{

    int ch = 5;
    cout << "\nEnter the numeber of virtex  ";
    cin >> numvirtex;
    cout << "\nEnter the number of Edges  ";
    cin >> numedges; 
    cout << "1)MAKE UNDIRECTED GRAPH 2)DISPLAY GRAPH 3)KRUSKAL'S ALGO 4)DISPLAY MINIMUN SPANNING TREE 5)EXIT";

    do
    {
        cout << "\nEnter Choice  ";
        cin >> ch;
        switch (ch)
        {
        case 1:
        {
             initiate();
              undirectedGraph();
            break;
        }
        case 2:
        {
            display();
            break;
        }
        case 3:
        {
             initiate();
            kushkalAlgoUndirected();

            cout << "\nthe cost of the Graph is : ";
            cout << cost<<endl;
            break;
         
        }
        case 4:
        {cout<<"\nThe adjecncy graph will be like this after algorithn :\n";
             display_min_spanning_tree();
           break;
        }
        case 5:
        {
            cout << "\nExited!!!";
            break;
        }
        default:
        {
            cout << "\nWrong Choice!!!";
            break;
        }
        }
    } while (ch != 5);
    return 0;
}